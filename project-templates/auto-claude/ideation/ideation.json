{
  "id": "ideation-20260109-142005",
  "project_id": "/Applications/Sites/Moderna_twig/thelia/templates/frontOffice/moderna",
  "config": {
    "enabled_types": [
      "performance_optimizations"
    ],
    "include_roadmap_context": true,
    "include_kanban_context": true,
    "max_ideas_per_type": 5
  },
  "ideas": [
    {
      "id": "ci-001",
      "type": "code_improvements",
      "title": "Add Live Search Results to SearchModal",
      "description": "Enhance the existing SearchModal component to display real-time product search results as the user types, instead of just showing 'Press Enter to see all results' placeholder. Results would appear in a dropdown with product images, titles, and prices.",
      "rationale": "The SearchModal.html.twig already exists with Alpine.js store integration ($store.search). The CartItemsController API pattern is established for fetching product data via JSON. The ProductCard TwigComponent provides the product display pattern. Only the API endpoint and frontend integration are missing.",
      "builds_upon": [
        "SearchModal component",
        "API Controller pattern (CartItemsController)",
        "Alpine.js store pattern"
      ],
      "estimated_effort": "small",
      "affected_files": [
        "src/Api/SearchController.php",
        "components/Layout/SearchModal.html.twig",
        "assets/js/app.js"
      ],
      "existing_patterns": [
        "CartItemsController for JSON API responses",
        "Alpine $store.search for state management",
        "ProductQuery for product lookups"
      ],
      "implementation_approach": "Create new SearchController.php following CartItemsController pattern with a /moderna-api/search endpoint. Add x-init to SearchModal to watch $store.search.query with debounce, fetching results when query.length > 2. Display results using existing product card styling patterns from ProductCard component.",
      "status": "draft",
      "created_at": "2026-01-09T14:25:00.000Z"
    },
    {
      "id": "ci-002",
      "type": "code_improvements",
      "title": "Add Product Comparison Feature",
      "description": "Create a product comparison system allowing customers to compare multiple products side-by-side. Includes add/remove to comparison functionality on product cards and a comparison drawer/page showing product attributes.",
      "rationale": "WishlistController already implements the exact pattern needed: add/remove/sync/clear operations with localStorage sync for anonymous users and database persistence for authenticated users. The wishlist-button.js Alpine component provides the toggle button pattern. The CartDrawer component provides the slide-out panel pattern.",
      "builds_upon": [
        "WishlistController API structure",
        "wishlist-button.js Alpine component",
        "CartDrawer slide-out panel"
      ],
      "estimated_effort": "medium",
      "affected_files": [
        "src/Api/ComparisonController.php",
        "assets/js/comparison-button.js",
        "components/Layout/ComparisonDrawer.html.twig",
        "src/UiComponents/Product/ProductCard.html.twig"
      ],
      "existing_patterns": [
        "WishlistController for CRUD operations",
        "wishlistButton() Alpine factory function",
        "Alpine.store pattern for comparison state",
        "CartDrawer for slide-out UI"
      ],
      "implementation_approach": "Copy WishlistController to ComparisonController, adapting customer_wishlist table to customer_comparison. Create comparison-button.js copying wishlist-button.js pattern. Add Alpine.store('comparison') following $store.wishlist pattern. Create ComparisonDrawer.html.twig based on CartDrawer structure showing products in columns.",
      "status": "draft",
      "created_at": "2026-01-09T14:25:00.000Z"
    },
    {
      "id": "ci-003",
      "type": "code_improvements",
      "title": "Create Button TwigComponent",
      "description": "Create a reusable Button TwigComponent following the Badge component pattern, providing consistent button styling with variants (primary, secondary, outline, ghost), sizes (sm, md, lg), and states (loading, disabled).",
      "rationale": "The Badge TwigComponent demonstrates the exact pattern: PHP class with variant properties and getCssClass() method, paired with Twig template. Currently buttons are styled inconsistently across templates. The Badge pattern of TYPE_COLOR_MAP and STATUS_COLOR_MAP provides the model for button variants.",
      "builds_upon": [
        "Badge TwigComponent",
        "Tailwind CSS button classes"
      ],
      "estimated_effort": "small",
      "affected_files": [
        "src/UiComponents/Common/Button/Button.php",
        "src/UiComponents/Common/Button/Button.html.twig",
        "assets/css/components/_button.css"
      ],
      "existing_patterns": [
        "Badge.php with variant properties and getCssClass()",
        "#[AsTwigComponent] registration",
        "#[ExposeInTemplate] for public properties",
        "BEM CSS naming in _badge.css"
      ],
      "implementation_approach": "Create Button.php with $variant, $size, $disabled, $loading properties following Badge.php structure. Implement getVariantClass(), getSizeClass(), getStateClass() methods. Create Button.html.twig using <button> with dynamic classes. Add _button.css with BEM classes for variants following _badge.css pattern.",
      "status": "draft",
      "created_at": "2026-01-09T14:25:00.000Z"
    },
    {
      "id": "ci-004",
      "type": "code_improvements",
      "title": "Add Price Formatter Twig Filter",
      "description": "Create a centralized |format_price Twig filter for consistent price formatting across all templates, supporting locale-aware currency display with proper decimal separators and currency symbols.",
      "rationale": "TaxedPriceExtension already establishes the Twig extension pattern. ProductCard.php has getTaxedPriceFormatted() with number_format(value, 2, ',', ' ') . ' \u20ac' logic duplicated across templates. A centralized filter would eliminate duplication and ensure consistency.",
      "builds_upon": [
        "TaxedPriceExtension Twig extension",
        "ProductCard price formatting methods"
      ],
      "estimated_effort": "trivial",
      "affected_files": [
        "src/Twig/PriceFormatterExtension.php"
      ],
      "existing_patterns": [
        "TaxedPriceExtension extending AbstractExtension",
        "TwigFunction registration in getFunctions()",
        "ProductCard.php number_format() usage"
      ],
      "implementation_approach": "Create PriceFormatterExtension.php extending AbstractExtension. Add getFilters() returning TwigFilter('format_price', ...). Implement formatPrice(float $price, ?string $currency = '\u20ac', ?string $locale = 'fr_FR') method using number_format with locale-appropriate separators. Register as service with autoconfigure: true.",
      "status": "draft",
      "created_at": "2026-01-09T14:25:00.000Z"
    },
    {
      "id": "ci-005",
      "type": "code_improvements",
      "title": "Add Recently Viewed Products Widget",
      "description": "Create a RecentlyViewed TwigComponent to display recently viewed products on product pages and homepage, using the existing RecentlyViewedController API for data.",
      "rationale": "RecentlyViewedController already provides /sync and /track API endpoints with full product data including images. The ProductCard TwigComponent provides the product display pattern. Only the widget component connecting these is missing. Anonymous users can use localStorage, authenticated users get server sync.",
      "builds_upon": [
        "RecentlyViewedController API",
        "ProductCard TwigComponent",
        "Alpine.js localStorage pattern from wishlist"
      ],
      "estimated_effort": "small",
      "affected_files": [
        "src/UiComponents/Product/RecentlyViewed.php",
        "src/UiComponents/Product/RecentlyViewed.html.twig",
        "assets/js/recently-viewed-store.js"
      ],
      "existing_patterns": [
        "RecentlyViewedController for API data",
        "ProductCard for product display",
        "Alpine.store('wishlist') for localStorage + server sync",
        "Product page tracking pattern"
      ],
      "implementation_approach": "Create Alpine.store('recentlyViewed') following wishlist store pattern with localStorage persistence and server sync via /moderna-api/recently-viewed/sync. Create RecentlyViewed.php TwigComponent with $maxItems property. Template uses x-for over $store.recentlyViewed.items to render ProductCard components. Add tracking on product page load.",
      "status": "draft",
      "created_at": "2026-01-09T14:25:00.000Z"
    },
    {
      "id": "uiux-001",
      "type": "ui_ux_improvements",
      "title": "Add Live Search Results Preview to Search Modal",
      "description": "Implement real-time search results preview as users type in the search modal, displaying product suggestions before form submission.",
      "rationale": "Currently the search modal only shows 'Press Enter to see all results' hint after typing. Live search results significantly improve UX by reducing friction, helping users find products faster, and enabling discovery of related items they might not have searched for directly.",
      "category": "usability",
      "affected_components": [
        "components/Layout/SearchModal.html.twig"
      ],
      "screenshots": [],
      "current_state": "The search modal has an input field with popular search suggestions. When users type more than 2 characters, they see a hint to press Enter. No live results are shown during typing.",
      "proposed_change": "Add an Alpine.js-powered live search that: 1) Debounces input (300ms) after 3+ characters, 2) Fetches results from /api/front/products with title search, 3) Displays up to 5 product matches with images, titles, and prices, 4) Shows a 'See all X results' link to the full search page. Include skeleton loading state during fetch.",
      "user_benefit": "Users can immediately see matching products without leaving the modal, reducing time-to-product by 50%+ and enabling quick navigation directly to desired items.",
      "status": "draft",
      "created_at": "2026-01-09T14:45:00.000Z"
    },
    {
      "id": "uiux-002",
      "type": "ui_ux_improvements",
      "title": "Enhance 404 Error Page with Product Suggestions",
      "description": "Transform the basic 404 page into a helpful landing page with search functionality and product recommendations.",
      "rationale": "The current 404 page is minimal - just a large '404', brief text, and a home link. Users who land on broken links are high-intent visitors who deserve a better recovery path. An enhanced 404 can recover these potential customers.",
      "category": "usability",
      "affected_components": [
        "404.html.twig"
      ],
      "screenshots": [],
      "current_state": "Basic 404 page with large error code, 'Page Not Found' title, explanation text, and single 'Back to Home' button. No search or product suggestions.",
      "proposed_change": "Redesign 404 page to include: 1) Friendly illustration or icon instead of stark '404', 2) Inline search bar allowing users to search from the error page, 3) Grid of 4 featured/promo products below search, 4) Links to main category pages, 5) Contact support link. Keep the visual design consistent with the Moderna theme.",
      "user_benefit": "Reduces bounce rate from error pages by giving users multiple paths to find what they need, transforming a dead-end into a discovery opportunity.",
      "status": "archived",
      "created_at": "2026-01-09T14:45:00.000Z",
      "linked_task_id": "008-enhance-404-error-page-with-product-suggestions"
    },
    {
      "id": "uiux-003",
      "type": "ui_ux_improvements",
      "title": "Add Skeleton Loading States for Product Grids",
      "description": "Implement skeleton placeholder animations for product card grids during data loading to improve perceived performance.",
      "rationale": "Category pages and search results currently have no skeleton loading states - users see empty space or a simple spinner while products load. Skeleton loaders significantly improve perceived performance and reduce layout shift.",
      "category": "performance",
      "affected_components": [
        "category.html.twig",
        "components/Home/ProductsGrid.html.twig",
        "components/Cart/Cart.html.twig"
      ],
      "screenshots": [],
      "current_state": "Product grids appear instantly only after data is fully loaded. During loading, users see either empty space or the page without products. The cart empty state suggestions section has no loading indication.",
      "proposed_change": "Create a reusable ProductCardSkeleton component that matches ProductCard dimensions. Add CSS @keyframes shimmer animation (left-to-right gradient). In Alpine.js product grid components, show 4-8 skeleton cards while loading=true. Use Tailwind's animate-pulse utility or custom shimmer for the effect. Include skeleton in: 1) Category product grids, 2) Search results, 3) Cart empty state suggestions, 4) Related products sections.",
      "user_benefit": "Creates a perception of faster load times, reduces cumulative layout shift (CLS), and gives users confidence that content is loading.",
      "status": "draft",
      "created_at": "2026-01-09T14:45:00.000Z"
    },
    {
      "id": "uiux-004",
      "type": "ui_ux_improvements",
      "title": "Improve Product Card Keyboard Accessibility",
      "description": "Make the product card wishlist button accessible via keyboard navigation and ensure proper focus states.",
      "rationale": "The wishlist button on product cards is only visible on mouse hover (opacity: 0 by default). This makes it completely inaccessible to keyboard users and screen reader users cannot discover the action without documentation.",
      "category": "accessibility",
      "affected_components": [
        "src/UiComponents/Product/ProductCard.html.twig",
        "assets/css/components/_product-card.css"
      ],
      "screenshots": [],
      "current_state": "Wishlist button has opacity: 0 and transform: scale(0.8) by default. It only becomes visible on .product-card:hover. While there's an @media (hover: none) rule for touch devices, keyboard focus is not handled.",
      "proposed_change": "1) Add :focus-visible selector to show wishlist button when focused via keyboard (.product-card:focus-within .product-card-wishlistBtn should also trigger visibility), 2) Add visible focus ring with outline or box-shadow matching the design system, 3) Add aria-label to the button describing its toggle state ('Add to wishlist' / 'Remove from wishlist'), 4) Ensure tabindex='0' is present. Update CSS to include .product-card-wishlistBtn:focus-visible { opacity: 1; transform: scale(1); outline: 2px solid var(--color-primary); outline-offset: 2px; }",
      "user_benefit": "Enables keyboard-only users to add products to their wishlist, improving accessibility compliance (WCAG 2.1 AA) and expanding site usability to all users.",
      "status": "draft",
      "created_at": "2026-01-09T14:45:00.000Z"
    },
    {
      "id": "uiux-005",
      "type": "ui_ux_improvements",
      "title": "Add Quantity Quick-Edit on Product Cards",
      "description": "Enable users to add products to cart with quantity selection directly from product cards, reducing clicks to purchase.",
      "rationale": "Currently, product cards only show product info and link to the detail page. Users must navigate to the product page to add items to cart. For returning customers or quick purchases, this adds unnecessary friction.",
      "category": "interaction",
      "affected_components": [
        "src/UiComponents/Product/ProductCard.html.twig",
        "assets/css/components/_product-card.css"
      ],
      "screenshots": [],
      "current_state": "Product cards display image, title, and price. The only interactive element is the wishlist button (on hover). To add to cart, users must click through to the product detail page.",
      "proposed_change": "Add an 'Add to Cart' button that appears on product card hover (similar to wishlist button position). For products without variants: 1) Single click adds 1 item and shows success feedback (cart icon animation), 2) Optional: hold/long-press reveals quantity selector (-/+). For products with variants: Button shows 'Select Options' and links to product page. Implement using Alpine.js x-data component that calls the existing cart API endpoint. Position the button at bottom of image area or in content section. Include loading spinner during add operation.",
      "user_benefit": "Reduces time-to-cart from 3+ clicks to 1 click for simple products. Enables quick bulk-shopping behavior and improves conversion rate for returning customers.",
      "status": "draft",
      "created_at": "2026-01-09T14:45:00.000Z"
    },
    {
      "id": "sec-001",
      "type": "security_hardening",
      "title": "Fix insecure cookie attributes on authentication cookies",
      "description": "In AuthController.php (lines 239-241 and 251), cookies are created with `Secure=false` and `HttpOnly=false`. The remember-me cookie specifically has `HttpOnly=false`, making it accessible to JavaScript and vulnerable to XSS-based theft. The cart cookie also uses `Secure=false`, allowing transmission over unencrypted HTTP connections.",
      "rationale": "Insecure cookie attributes expose authentication tokens to theft via XSS attacks and man-in-the-middle attacks. Session hijacking can lead to complete account takeover, allowing attackers to impersonate users, access their orders, payment information, and personal data.",
      "category": "authentication",
      "severity": "high",
      "affectedFiles": [
        "src/Api/AuthController.php",
        "src/EventSubscriber/CartCookieSubscriber.php"
      ],
      "vulnerability": "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute, CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag",
      "currentRisk": "Authentication and cart cookies can be stolen via XSS or intercepted over HTTP connections, enabling session hijacking",
      "remediation": "Set `Secure=true` for all cookies when the application is served over HTTPS. Set `HttpOnly=true` for authentication-related cookies (remember-me, session). Add `SameSite=Lax` or `SameSite=Strict` attribute to prevent CSRF attacks via cookies. Update Cookie::create() calls to use secure defaults.",
      "references": [
        "https://owasp.org/www-community/controls/SecureCookieAttribute",
        "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      ],
      "compliance": [
        "PCI-DSS",
        "GDPR"
      ]
    },
    {
      "id": "sec-002",
      "type": "security_hardening",
      "title": "Add CSRF protection to authentication API endpoints",
      "description": "The login endpoint (`/moderna-api/auth/login`), registration endpoint (`/moderna-api/register`), and wishlist endpoints (`/moderna-api/wishlist/*`) lack CSRF token validation. While address and customer update forms properly implement CSRF protection via `csrf_token()`, the JSON API endpoints for authentication are unprotected.",
      "rationale": "Without CSRF protection, attackers can craft malicious pages that submit login/registration requests on behalf of authenticated users. This enables login CSRF attacks where victims are logged into attacker-controlled accounts, potentially exposing their activities. For wishlist endpoints, attackers could manipulate user wishlists.",
      "category": "authorization",
      "severity": "high",
      "affectedFiles": [
        "src/Api/AuthController.php",
        "src/Api/RegistrationController.php",
        "src/Api/WishlistController.php",
        "login.html.twig",
        "register.html.twig"
      ],
      "vulnerability": "CWE-352: Cross-Site Request Forgery (CSRF)",
      "currentRisk": "Attackers can perform login CSRF attacks to associate victims with attacker accounts, or manipulate wishlists without user consent",
      "remediation": "Implement CSRF token validation on all state-changing API endpoints. For SPA/AJAX requests, use the Double Submit Cookie pattern or include a CSRF token from the session in request headers. Add `csrf_token()` generation in templates and validate using `$this->isCsrfTokenValid()` in controllers. Consider using Symfony's CSRF protection bundle for consistent implementation.",
      "references": [
        "https://owasp.org/www-community/attacks/csrf",
        "https://symfony.com/doc/current/security/csrf.html",
        "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      ],
      "compliance": [
        "OWASP Top 10"
      ]
    },
    {
      "id": "sec-003",
      "type": "security_hardening",
      "title": "Implement rate limiting on authentication endpoints",
      "description": "The login (`/moderna-api/auth/login`), registration (`/moderna-api/register`), and forgot-password (`/moderna-api/auth/forgot-password`) endpoints have no rate limiting implementation. There are no checks for repeated failed login attempts or protection against automated registration abuse.",
      "rationale": "Without rate limiting, attackers can perform brute-force password attacks at scale, credential stuffing attacks using leaked credential databases, and automated account creation for spam or abuse. The forgot-password endpoint could be abused for email flooding attacks against users.",
      "category": "authentication",
      "severity": "high",
      "affectedFiles": [
        "src/Api/AuthController.php",
        "src/Api/RegistrationController.php"
      ],
      "vulnerability": "CWE-307: Improper Restriction of Excessive Authentication Attempts",
      "currentRisk": "Account compromise via brute-force attacks, credential stuffing from data breaches, and abuse of registration system for spam",
      "remediation": "Implement rate limiting using Symfony's RateLimiter component. Apply limits per IP and per account for login attempts (e.g., 5 attempts per minute, progressive lockout). Add CAPTCHA verification after failed attempts. For registration, limit requests per IP (e.g., 3 accounts per hour). Track failed login attempts in database and implement temporary account lockout. Add rate limiting to forgot-password endpoint.",
      "references": [
        "https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks",
        "https://symfony.com/doc/current/rate_limiter.html",
        "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      ],
      "compliance": [
        "PCI-DSS",
        "SOC2"
      ]
    },
    {
      "id": "sec-004",
      "type": "security_hardening",
      "title": "Sanitize user-generated content rendered with |raw filter to prevent stored XSS",
      "description": "Multiple Twig templates use the `|raw` filter to render content that could contain user or admin input: category descriptions (`category.html.twig:40`), product descriptions (`product.html.twig:375`), and wishlist HTML attributes (`ProductCard.html.twig:45`). While this content typically comes from admin-entered data, stored XSS is possible if any admin account is compromised or if the data source is not properly validated on input.",
      "rationale": "Stored XSS vulnerabilities allow attackers to inject malicious JavaScript that executes in victims' browsers when viewing affected pages. This can lead to session hijacking, credential theft, phishing, and malware distribution. In an e-commerce context, attackers could steal payment information or redirect users to malicious sites.",
      "category": "input_validation",
      "severity": "medium",
      "affectedFiles": [
        "category.html.twig",
        "product.html.twig",
        "src/UiComponents/Product/ProductCard.html.twig"
      ],
      "vulnerability": "CWE-79: Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)",
      "currentRisk": "Stored XSS if admin accounts are compromised or if CMS content is not properly sanitized on input, potentially affecting all site visitors",
      "remediation": "Implement a whitelist-based HTML sanitizer for rich content fields. Use a library like HTMLPurifier or Symfony's HtmlSanitizer component to strip dangerous tags and attributes while preserving safe formatting. Apply sanitization on both input (when saving to database) and output (as defense in depth). For attributes like `wishlistAttributesHtml`, escape individual values and construct HTML programmatically rather than rendering raw HTML strings.",
      "references": [
        "https://owasp.org/www-community/attacks/xss/",
        "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html",
        "https://symfony.com/doc/current/html_sanitizer.html"
      ],
      "compliance": [
        "OWASP Top 10",
        "PCI-DSS"
      ]
    },
    {
      "id": "sec-005",
      "type": "security_hardening",
      "title": "Remove exception message exposure from API error responses",
      "description": "Multiple API controllers expose internal exception messages directly in HTTP responses. In DataController.php (lines 69, 111, 164) and other controllers, error responses include `'message' => $e->getMessage()`, potentially leaking sensitive implementation details, database structure, or file paths to attackers.",
      "rationale": "Detailed error messages help attackers understand the application's internal structure, identify vulnerable components, and craft targeted attacks. Exception messages may reveal database table names, SQL queries, file paths, or third-party service configurations. This information disclosure aids reconnaissance for more sophisticated attacks.",
      "category": "configuration",
      "severity": "medium",
      "affectedFiles": [
        "src/Api/DataController.php",
        "src/Api/AuthController.php",
        "src/Api/WishlistController.php"
      ],
      "vulnerability": "CWE-209: Generation of Error Message Containing Sensitive Information",
      "currentRisk": "Attackers can gather internal implementation details, database structure, and infrastructure information through error messages to plan targeted attacks",
      "remediation": "Return generic error messages to users while logging detailed exceptions server-side. Create a centralized exception handler that: (1) logs full exception details with stack traces for debugging, (2) returns user-friendly generic messages like 'An error occurred, please try again', (3) includes a unique error ID for correlation. In production, ensure `APP_ENV=prod` disables debug mode. Implement structured logging with correlation IDs for troubleshooting without exposing details to users.",
      "references": [
        "https://owasp.org/www-community/Improper_Error_Handling",
        "https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html"
      ],
      "compliance": [
        "OWASP Top 10",
        "SOC2"
      ]
    },
    {
      "id": "perf-001",
      "type": "performance_optimizations",
      "title": "Optimize Google Fonts loading - Replace render-blocking @import with preload",
      "description": "The Plus Jakarta Sans font is loaded via @import in CSS (app.css:6), which is render-blocking and delays First Contentful Paint. This causes a flash of unstyled text (FOUT) or invisible text (FOIT) while the font loads.",
      "rationale": "@import in CSS is one of the worst ways to load fonts - it blocks CSS parsing until the font loads. Moving to <link rel='preload'> with font-display: swap allows the page to render immediately with a fallback font, then swap to the custom font when ready. This is a Core Web Vitals best practice that directly improves LCP and FCP metrics.",
      "category": "rendering",
      "impact": "high",
      "affectedAreas": [
        "assets/css/app.css",
        "base.html.twig"
      ],
      "currentMetric": "Font @import blocks CSS parsing, delays FCP by 200-500ms on typical connections",
      "expectedImprovement": "~200-400ms improvement in First Contentful Paint, eliminates render-blocking resource",
      "implementation": "1. Remove @import from app.css\n2. Add preconnect hints to base.html.twig (already present)\n3. Add <link rel='preload' as='font'> for the font file\n4. Use font-display: swap in @font-face declaration\n5. Consider self-hosting the font for better control and reduced third-party dependency",
      "tradeoffs": "Minor FOUT (flash of unstyled text) may occur as fallback font swaps to custom font, but this is preferable to blocking render",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-002",
      "type": "performance_optimizations",
      "title": "Consolidate duplicate auth check API calls on page load",
      "description": "On DOMContentLoaded, the application makes two separate /moderna-api/auth/check API calls - one for wishlist store (app.js:457) and one for recentlyViewed store (app.js:464). This doubles the authentication request overhead on every page load.",
      "rationale": "Each auth check is an HTTP round-trip that adds latency. By consolidating into a single shared auth check, we reduce network requests by 50% for this operation. The auth state is the same for both stores, so a single call can update both. This also reduces server load.",
      "category": "network",
      "impact": "medium",
      "affectedAreas": [
        "assets/js/app.js"
      ],
      "currentMetric": "2 API calls to /moderna-api/auth/check on every page load",
      "expectedImprovement": "50% reduction in auth-related API calls, ~100-200ms faster Time to Interactive",
      "implementation": "1. Create a shared auth check function that caches the result\n2. Call checkAuth() once and share result between wishlist and recentlyViewed stores\n3. Consider using a shared Alpine store for auth state\n4. Example: const isAuth = await checkSharedAuth(); if(isAuth) { wishlistStore.syncWithServer(); recentlyViewedStore.syncWithServer(); }",
      "tradeoffs": "Slightly more coupling between stores, but the auth state is inherently shared",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-003",
      "type": "performance_optimizations",
      "title": "Fix memory leaks in wishlist button event listeners",
      "description": "The wishlistButton component (wishlist-button.js and inline in index.html.twig) adds event listeners in init() for 'wishlist:added', 'wishlist:removed', and 'wishlist:cleared' events but never removes them. As product cards are created/destroyed (pagination, filtering, SPA navigation), orphaned listeners accumulate, causing memory leaks.",
      "rationale": "Each product card on the page creates 3 event listeners that persist even after the DOM element is removed. On a category page with 20 products, loading 5 pages creates 300 orphaned listeners. This leads to increased memory usage, slower event dispatch, and potential application crashes on long sessions.",
      "category": "memory",
      "impact": "medium",
      "affectedAreas": [
        "assets/js/wishlist-button.js",
        "index.html.twig"
      ],
      "currentMetric": "3 global event listeners per product card that are never cleaned up",
      "expectedImprovement": "Eliminates memory leak, stable memory usage during browsing sessions, prevents performance degradation over time",
      "implementation": "1. Add a destroy() method to wishlistButton component\n2. Store listener references for removal: this._listeners = {added: () => this.checkWishlist(), ...}\n3. Use x-on:remove or equivalent to call cleanup\n4. For Alpine: use $cleanup or register cleanup in destroy callback\n5. Consider using event delegation on a parent container instead of per-card listeners",
      "tradeoffs": "Requires adding cleanup logic and tracking listener references",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-004",
      "type": "performance_optimizations",
      "title": "Eliminate N+1 query pattern for category images on homepage",
      "description": "The homepage (index.html.twig:115) makes a separate API call for category images inside a Twig loop: for each of the 4 categories displayed, it calls resources('/api/front/category_images', {'category.id': category.id}). This creates 4 additional API requests on every homepage load.",
      "rationale": "N+1 queries are a classic performance anti-pattern. The homepage currently makes 5+ API calls (categories, featured product, promo products, new products, plus 4 category image calls). Batch-fetching category images or including them in the initial categories API response would reduce this to 4 total calls, improving TTFB and reducing server load.",
      "category": "database",
      "impact": "high",
      "affectedAreas": [
        "index.html.twig",
        "Backend API (if configurable)"
      ],
      "currentMetric": "4+ sequential API calls for category images, 50-200ms each",
      "expectedImprovement": "~200-600ms reduction in homepage load time, 80% fewer API calls for category data",
      "implementation": "1. Option A: Modify API to include images in /api/front/categories response via 'include' parameter\n2. Option B: Create a batch endpoint: /api/front/category_images?category.id[]=1&category.id[]=2...\n3. Option C: Pre-fetch all category images in a single call before the loop\n4. Cache the results using Twig caching if available",
      "tradeoffs": "Requires backend API changes or Twig-level optimization; may need coordination with backend team",
      "estimatedEffort": "medium"
    },
    {
      "id": "perf-005",
      "type": "performance_optimizations",
      "title": "Move inline CSS from index.html.twig to compiled stylesheet",
      "description": "The homepage template (index.html.twig) contains ~390 lines of inline CSS within <style> tags (lines 201-592). This CSS is parsed on every page load and cannot be cached separately from the HTML response.",
      "rationale": "Inline CSS increases HTML payload size and bypasses browser caching. The ~15KB of inline styles are re-downloaded and re-parsed on every homepage visit. Moving these to the compiled app.css allows browser caching, reduces HTML payload, enables better minification, and improves maintainability by centralizing styles.",
      "category": "bundle_size",
      "impact": "medium",
      "affectedAreas": [
        "index.html.twig",
        "assets/css/app.css",
        "assets/css/components/ (new files)"
      ],
      "currentMetric": "~390 lines (~15KB) of inline CSS per homepage load",
      "expectedImprovement": "~15KB reduction in HTML payload, styles cached on repeat visits, better compression ratios",
      "implementation": "1. Extract homepage styles to assets/css/pages/_home.css\n2. Import in app.css: @import './pages/_home.css'\n3. Verify styles compile correctly with PostCSS/Tailwind\n4. Remove inline <style> block from index.html.twig\n5. Test slider, hero, and all homepage components",
      "tradeoffs": "Slightly increases initial CSS bundle size, but benefits outweigh costs due to caching",
      "estimatedEffort": "small"
    }
  ],
  "project_context": {
    "existing_features": [],
    "tech_stack": [
      "JavaScript"
    ],
    "target_audience": "E-commerce store owners using Thelia 3 who need a modern, responsive front-office template for their online shop",
    "planned_features": [
      "Dark Mode Support",
      "Enhanced 404 Page",
      "Back-in-Stock Notifications",
      "Specification: Am\u00e9lioration de la Page Favoris",
      "Icon System Consolidation",
      "Enhanced Guest Checkout",
      "Password Change API Implementation",
      "Product Recommendations Engine",
      "Multi-Currency Support Enhancement",
      "Newsletter Backend Integration",
      "Wishlist Sharing Feature",
      "One-Page Checkout Option",
      "Developer Documentation Portal",
      "Product Comparison Feature",
      "Mobile Checkout Optimization",
      "Enhance 404 Error Page with Product Suggestions",
      "Progressive Web App (PWA) Support",
      "SEO Structured Data (Schema.org)",
      "Product Reviews & Ratings System",
      "Advanced Search with Filters",
      "Automated Testing Suite",
      "Price Drop Alerts",
      "Product Quick View Modal",
      "Specification: Am\u00e9lioration de la Page 404",
      "Core Web Vitals Optimization"
    ]
  },
  "summary": {
    "total_ideas": 20,
    "by_type": {
      "code_improvements": 5,
      "ui_ux_improvements": 5,
      "security_hardening": 5,
      "performance_optimizations": 5
    },
    "by_status": {
      "draft": 19,
      "archived": 1
    }
  },
  "generated_at": "2026-01-09T14:20:05.091264",
  "updated_at": "2026-01-09T17:26:38.920106"
}